<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>ECMAscript6</title>

        <!-- 
            ECMAscript 2015 (애크마 스크립트 6)
            1. 새로운 변수 선언 키워드: let(변수), const(샹수)
            2. class키워드(객체), extends키워드(상속)
            3. 화살표 함수(Arrow Function) - 람다식
            4. module 문법: import(다른문서 가져다 사용), export(다른 문서에서 이 문서 사용 허용)
         -->

        <script>
            
            // 1. 변수선언 키워드 추가: let, const
            // 기존의 var 변수와의 차이점
            var a = 10;
            document.write(a+"<br>");
            var a = 20;
            document.write(a+"<br>");
            // var은 같은 이름의 변수를 사용해도 에러가 아님
            // 새로운 let키워드 변수
            let b = 100;
            document.write(b+"<br>");
            // let b = 100;
            // document.write(b+"<br>");
            // let은 같은 이름의 변수를 사용하면 에러(문법적 에러 - 에러 지점 이전도 동작안함)
            b = 200;
            document.write(b+"<br>");
            // 새로운 const키워드: 상수만드는 키워드
            const c = 100;
            document.write(c+"<br>");
            //c = 200;    //ERROR: 상수는 값 변경 불가 (논리적에러: 이 위치 이전까지는 동작)
            //document.write(c+"<br>");
            //const c = 200;  //같은 이름의 변수 사용은 let과 마찬가지로 문법적 에러
            //document.write(c+"<br>");

            // let, const도 역시 동적타이핑 문법이어서 자료형 마음대로 사용가능
            let d = "aaa";
            document.write(d+"<br>");
            d = 30;     //자료형 변경
            document.write(d+"<br>");
            d = new Date();     //자료형 변경
            document.write(d+"<br>");

            document.write("<br>");

            // 같은 이름 사용을 제한하는것 외에
            // let, const를 사용하게된 결정적인 이유: 인식범위에 대한 차이
            // var키워드는 함수단위로 인식(function scope)
            // let, const는 블럭단위( {} )로 인식(block scope)

            // 연습1) 
            // var
            var g = 10;
            if(true){
                var g = 20;
                document.write(g+"<br>");   //출력: 20
            }
            // 중괄호가 아니라 함수단위이므로 중괄호 안에 있는것도 지역변수로 생각하지 않는다
            document.write(g+"<br>");   //출력: 20

            // let
            let h = 10;
            if(true){
                let h = 20;
                document.write(h+"<br>");   //출력: 20
            }
            // 블록단위이므로 중괄호 안에 있는것을 지역변수로 생각
            document.write(h+"<br>");   //출력: 10

            // 연습2) 
            // var
            if(true){
                var j = 50;
                document.write(j+"<br>");   //출력: 50
            }
            document.write(j+"<br>");   //출력; 50

            // let
            if(true){
                let m = 50;
                document.write(m+"<br>");   //출력: 50
            }
            //document.write(m+"<br>");   //error: m이 뭔지 인식 못함 (논리적 에러)

            //연습3) var이 함수 단위라는 것을 확인
            var n = 10; //전역변수
            function aaa(){
                var n = 5;  //지역변수
                document.write(n+"<br>");   //출력: 5
            }
            aaa();  //호출해야 함수 실행
            document.write(n+"<br>");   //출력: 10

            function bbb(){
                var p = 20;
            }
            bbb();
            //document.write(p+"<br>");   //error: p가 뭔지 인식 못함(논리적 에러)

            // 함수도 block이므로 let은 당연히 위와 같은 동작.

            // 반복문 사용할 때
            for(var i=0; i<3; i++){
                document.write("aaaa<br>");
            }
            document.write(i+"<br>");

            for(let k=0; k<3; k++){
                document.write("bbbb<br>");
            }
            //document.write(k+"<br>");   //k가 뭔지 인식 못함(논리적 에러)

            // Hoisting 기술: 변수선언보다 사용을 먼저해도 변수선언의 사용 이전으로 선언문을 이동시켜주는 기술 - 단, 변수선언과 초기화(메모리할당)만 이동되고 값의 대입은 이동하지 않음
            document.write('<hr>');
            document.write(x+"<br>");   //error: x를 만든적이 없으므로 논리적 에러
            var x = 10;     //하지만 뒤에서 변수를 만들면 Hoisting(호이스팅)으로 인해 인식(출력: undefined) 
            
            //document.write(y+"<br>");   //error: y를 만든적이 없으므로 논리적 에러
            let y = 50;     //let은 Hoisting이 되긴하지만, 프로세스에 변수명만 등록되고 초기화는 안되서(메모리할당이 안됨) 에러

            // let의 Hoisting 확인하기
            let z = 100;
            {
                // 밑의 z가 Hoisting 안된다면 위의 z가 출력될 것이다.
                document.write(z+"<br>");   //error: 밑의 z가 Hoisting 되었지만 메모리에 로딩되지 않아서
                //let z = 50;
            }


            
        </script>

    </head>
    <body>
        
    </body>
</html>